package generate

import (
	"fmt"
	"github.com/brianvoe/gofakeit"
	"github.com/stretchr/testify/require"
	"github.com/terryhay/argtools/internal/generator/configYaml"
	"github.com/terryhay/argtools/pkg/argParserConfig"
	"sort"
	"testing"
)

func TestGenerate(t *testing.T) {
	t.Parallel()

	randNameCount := 9
	sortedRandNames := make([]string, 0, randNameCount)
	for i := 0; i < randNameCount; i++ {
		sortedRandNames = append(sortedRandNames, gofakeit.Color())
	}
	sort.Strings(sortedRandNames)

	command := configYaml.Command(sortedRandNames[0])
	additionalCommand := configYaml.Command(sortedRandNames[1])
	commandDescriptionHelpInfo := sortedRandNames[2]

	helpCommand := configYaml.Command(sortedRandNames[3])
	additionalHelpCommand := configYaml.Command(sortedRandNames[4])

	requiredFlag1 := "-" + configYaml.Flag(sortedRandNames[5])
	requiredFlag1Description := &configYaml.FlagDescription{
		Flag: requiredFlag1,
		ArgumentsDescription: &configYaml.ArgumentsDescription{
			AmountType: argParserConfig.ArgAmountTypeSingle,
			DefaultValues: []string{
				gofakeit.Name(),
			},
			AllowedValues: []string{
				gofakeit.Name(),
			},
		},
	}

	requiredFlag2 := "-" + configYaml.Flag(sortedRandNames[6])
	requiredFlag2Description := &configYaml.FlagDescription{
		Flag: requiredFlag2,
		ArgumentsDescription: &configYaml.ArgumentsDescription{
			AmountType: argParserConfig.ArgAmountTypeList,
			DefaultValues: []string{
				gofakeit.Name(),
			},
			AllowedValues: []string{
				gofakeit.Name(),
			},
		},
	}

	optionalFlag1 := "-" + configYaml.Flag(sortedRandNames[7])
	optionalFlag1Description := &configYaml.FlagDescription{
		Flag: optionalFlag1,
	}

	optionalFlag2 := "-" + configYaml.Flag(sortedRandNames[8])
	optionalFlag2Description := &configYaml.FlagDescription{
		Flag: optionalFlag2,
	}

	config := &configYaml.Config{
		AppHelpDescription: &configYaml.AppHelpDescription{},
		HelpCommandDescription: &configYaml.HelpCommandDescription{
			Command: helpCommand,
			AdditionalCommands: []configYaml.Command{
				additionalHelpCommand,
			},
		},
		NullCommandDescription: &configYaml.NullCommandDescription{
			ArgumentsDescription: &configYaml.ArgumentsDescription{},
			RequiredFlags: []configYaml.Flag{
				requiredFlag1,
				requiredFlag2,
			},
			OptionalFlags: []configYaml.Flag{
				optionalFlag1,
				optionalFlag2,
			},
		},
		CommandDescriptions: []*configYaml.CommandDescription{
			{
				Command: command,
				AdditionalCommands: []configYaml.Command{
					additionalCommand,
				},
				DescriptionHelpInfo: commandDescriptionHelpInfo,
				ArgumentsDescription: &configYaml.ArgumentsDescription{
					AmountType: argParserConfig.ArgAmountTypeSingle,
					DefaultValues: []string{
						gofakeit.Name(),
					},
					AllowedValues: []string{
						gofakeit.Name(),
					},
				},
				RequiredFlags: []configYaml.Flag{
					requiredFlag1,
					requiredFlag2,
				},
				OptionalFlags: []configYaml.Flag{
					optionalFlag1,
					optionalFlag2,
				},
			},
			{
				// fake empty command
				ArgumentsDescription: &configYaml.ArgumentsDescription{
					AmountType: argParserConfig.ArgAmountTypeList,
					DefaultValues: []string{
						gofakeit.Name(),
					},
					AllowedValues: []string{
						gofakeit.Name(),
					},
				},
			},
		},
		FlagDescriptions: []*configYaml.FlagDescription{
			requiredFlag1Description,
			requiredFlag2Description,
			optionalFlag1Description,
			optionalFlag2Description,
		},
	}

	argParserFileText := Generate(
		config,
		map[configYaml.Flag]*configYaml.FlagDescription{
			requiredFlag1: requiredFlag1Description,
			requiredFlag2: requiredFlag2Description,
			optionalFlag1: optionalFlag1Description,
			optionalFlag2: optionalFlag2Description,
		})

	expectedArgParserFileText := fmt.Sprintf(`// This code was generated by argtools.generator. DO NOT EDIT

package argTools

import (
	"github.com/terryhay/argtools/internal/argParserImpl"
	"github.com/terryhay/argtools/pkg/argParserConfig"
	"github.com/terryhay/argtools/pkg/argtoolsError"
	"github.com/terryhay/argtools/pkg/helpPrinter"
	"github.com/terryhay/argtools/pkg/parsedData"
)

const (
	// CommandIDNullCommand - 
	CommandIDNullCommand argParserConfig.CommandID = iota + 1
	//  - 
	
	// CommandID%[1]s - %[2]s
	CommandID%[1]s
	// CommandID%[3]s - print help info
	CommandID%[3]s
)

const (
	//  - 
	 argParserConfig.Command = ""
	// Command%[1]s - %[2]s
	Command%[1]s = "%[1]s"
	// Command%[4]s - %[2]s
	Command%[4]s = "%[4]s"
	// Command%[5]s - print help info
	Command%[5]s = "%[5]s"
	// Command%[6]s - print help info
	Command%[6]s = "%[6]s"
)

const (
	// Flag%[7]s - 
	Flag%[7]s argParserConfig.Flag = "-%[7]s"
	// Flag%[8]s - 
	Flag%[8]s = "-%[8]s"
	// Flag%[9]s - 
	Flag%[9]s = "-%[9]s"
	// Flag%[10]s - 
	Flag%[10]s = "-%[10]s"
)

// Parse - processes command line arguments
func Parse(args []string) (res *parsedData.ParsedData, err *argtoolsError.Error) {
	appArgConfig := argParserConfig.NewArgParserConfig(
		// appDescription
		argParserConfig.ApplicationDescription{
			AppName: "",
			NameHelpInfo: "",
			DescriptionHelpInfo: "",
		},
		// flagDescriptions
		map[argParserConfig.Flag]*argParserConfig.FlagDescription{
			Flag%[7]s: {
				DescriptionHelpInfo:  "",
				ArgDescription: &argParserConfig.ArgumentsDescription{
					AmountType:              argParserConfig.ArgAmountTypeSingle,
					SynopsisHelpDescription: "",
					DefaultValues: []string{
						"%[11]s",
					},
					AllowedValues: map[string]bool{
						"%[12]s": true,
					},
				},
			},
			Flag%[8]s: {
				DescriptionHelpInfo:  "",
				ArgDescription: &argParserConfig.ArgumentsDescription{
					AmountType:              argParserConfig.ArgAmountTypeList,
					SynopsisHelpDescription: "",
					DefaultValues: []string{
						"%[13]s",
					},
					AllowedValues: map[string]bool{
						"%[14]s": true,
					},
				},
			},
			Flag%[9]s: {
				DescriptionHelpInfo:  "",
			},
			Flag%[10]s: {
				DescriptionHelpInfo:  "",
			},
		},
		// commandDescriptions
		[]*argParserConfig.CommandDescription{
			{
				ID: CommandID%[1]s,
				Commands: map[argParserConfig.Command]bool{
					Command%[1]s: true,
					Command%[4]s: true,
				},
				RequiredFlags: map[argParserConfig.Flag]bool{
					Flag%[7]s: true,
					Flag%[8]s: true,
				},
				OptionalFlags: map[argParserConfig.Flag]bool{
					Flag%[9]s: true,
					Flag%[10]s: true,
				},
			},
			{
				ID: ,
				Commands: map[argParserConfig.Command]bool{
					: true,
				},
			},
			{
				ID: CommandID%[3]s,
				Commands: map[argParserConfig.Command]bool{
					Command%[3]s: true,
					Command%[6]s: true,
				},
			},
		},
		// nullCommandDescription
		&argParserConfig.NullCommandDescription{
			ID: CommandIDNullCommand,
			DescriptionHelpInfo: "",
				ArgDescription: &argParserConfig.ArgumentsDescription{
					AmountType:              argParserConfig.ArgAmountTypeNoArgs,
					SynopsisHelpDescription: "",
				},
		},
)

	if res, err = argParserImpl.NewCmdArgParserImpl(appArgConfig).Parse(args); err != nil {
		return nil, err
	}

	if res.GetCommandID() == CommandID%[3]s {
		helpPrinter.PrintHelpInfo(*appArgConfig)
		return nil, nil
	}

	return res, nil
}
`,
		command, commandDescriptionHelpInfo, helpCommand, additionalCommand, helpCommand, additionalHelpCommand,
		requiredFlag1[1:], requiredFlag2[1:], optionalFlag1[1:], optionalFlag2[1:],
		requiredFlag1Description.GetArgumentsDescription().GetDefaultValues()[0], requiredFlag1Description.GetArgumentsDescription().GetAllowedValues()[0],
		requiredFlag2Description.GetArgumentsDescription().GetDefaultValues()[0], requiredFlag2Description.GetArgumentsDescription().GetAllowedValues()[0],
	)

	require.Equal(t, expectedArgParserFileText, argParserFileText)
}

func TestGenerateWithoutNullCommand(t *testing.T) {
	t.Parallel()

	helpCommand := configYaml.Command(gofakeit.Color())
	additionalHelpCommand := configYaml.Command(gofakeit.Color())

	argParserFileText := Generate(
		&configYaml.Config{
			AppHelpDescription: &configYaml.AppHelpDescription{},
			HelpCommandDescription: &configYaml.HelpCommandDescription{
				Command: helpCommand,
				AdditionalCommands: []configYaml.Command{
					additionalHelpCommand,
				},
			},
		},
		nil)

	require.Equal(t, fmt.Sprintf(`// This code was generated by argtools.generator. DO NOT EDIT

package argTools

import (
	"github.com/terryhay/argtools/internal/argParserImpl"
	"github.com/terryhay/argtools/pkg/argParserConfig"
	"github.com/terryhay/argtools/pkg/argtoolsError"
	"github.com/terryhay/argtools/pkg/helpPrinter"
	"github.com/terryhay/argtools/pkg/parsedData"
)

const (
	// CommandID%[1]s - print help info
	CommandID%[1]s argParserConfig.CommandID = iota + 1
)

const (
	// Command%[1]s - print help info
	Command%[1]s argParserConfig.Command = "%[1]s"
	// Command%[2]s - print help info
	Command%[2]s = "%[2]s"
)

const (
)

// Parse - processes command line arguments
func Parse(args []string) (res *parsedData.ParsedData, err *argtoolsError.Error) {
	appArgConfig := argParserConfig.NewArgParserConfig(
		// appDescription
		argParserConfig.ApplicationDescription{
			AppName: "",
			NameHelpInfo: "",
			DescriptionHelpInfo: "",
		},
		// flagDescriptions
nil,
		// commandDescriptions
		[]*argParserConfig.CommandDescription{
			{
				ID: CommandID%[1]s,
				Commands: map[argParserConfig.Command]bool{
					Command%[1]s: true,
					Command%[2]s: true,
				},
			},
		},
		// nullCommandDescription
		nil)

	if res, err = argParserImpl.NewCmdArgParserImpl(appArgConfig).Parse(args); err != nil {
		return nil, err
	}

	if res.GetCommandID() == CommandIDDarkSlateGray {
		helpPrinter.PrintHelpInfo(*appArgConfig)
		return nil, nil
	}

	return res, nil
}
`, helpCommand, additionalHelpCommand), argParserFileText)
}
